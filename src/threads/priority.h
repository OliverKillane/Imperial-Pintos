#ifndef THREADS_PRIORITY_H
#define THREADS_PRIORITY_H

#include <stdbool.h>
#include <stdint.h>
#include <list.h>
#include <priority_queue.h>
#include <fixed-point.h>

/* The library for calculating threads' priorities and choosing which one to
 * schedule accordingly
 *
 * The library is split into several parts: thread queue, donation system and
 * mlfqs priority calculation. The thread queue is responsible for deciding on
 * which thread should be scheduled next, based on the current priority of a
 * thread generated by the donation system or the mlfqs calculation. The
 * priority donation system works according to the part 3.3.4 of the spec
 * and keeps track of a graph of priority donation. There is a slight change to
 * it, and that is that locks do also have a priority that they donate to
 * the thread holding them. The mlfqs priority calculation system works exactly
 * as outlined in appendix B of the spec, with the averaging of the load average
 * and recent cpu carried out every second using mlfqs_decay() and the
 * incrementing of the recent cpu value carried out using mlqfs_tick().
 *
 * In terms of synchronization, since the thread queue is used directly in
 * the rescheduling, it has to be callable from an interrupt context, so
 * therefore cannot use synchronization primitives. However, everything else is
 * only called only in non-interrupt context, so can use primitives from sync.h
 * for synchronization. Particularly, the tree traversal in the donation system
 * uses hand-over-hand locking using semaphores (we cannot use the locks since
 * then they would have to be added to the donation system). The thread queue
 * should however disable interrupts on its own as well, in case it gets called
 * outside of interrupt context.
 */

/* Forward declaration of lock and thread */
struct lock;
struct thread;

/* Maximum depth to which the donation is updated */
#define DONATION_MAX_DEPTH 16
_Static_assert(DONATION_MAX_DEPTH, "DONATION_MAX_DEPTH must be positive");

/* Priority data about the lock used in the priority donation system */
struct lock_priority {
	int8_t priority; /* Lock's current computed priority */
	struct thread *donee; /* The thread that receives the lock's priority */
	struct pqueue_elem elem; /* Used in donee's pqueue of donors */
	struct list donors; /* Threads donating their priority to the lock */
};

/* Priority data about the thread used in both scheduling systems */
struct thread_priority {
	int8_t priority; /* Thread's current computed priority */
	union {
		struct {
			int8_t niceness; /* Niceness ranges from 20 to -20 */
			fixed32 recent_cpu; /* Measure of cpu usage */
		};
		struct {
			int8_t base_priority; /* Thread's base priority */
			struct lock *donee; /* The lock that receives the thread's priority */
			struct list_elem elem; /* Used in donee's list of donors */
			struct pqueue donors; /* Locks donating their priority to the thread */
		};
	};
};

/* A round robin queue (using a list) that can itself be added to a list */
struct ready_queue {
	struct list thread_queue; /* Holds a queue of threads of the same priority */
	struct list_elem elem; /* Used to link the ready_queues together */
};

/* If false (default), use round-robin scheduler.
 * If true, use multi-level feedback queue scheduler.
 * Controlled by kernel command-line option "mlfqs".
 */
extern bool thread_mlfqs;

/* Thread picking system */
void tqueue_init(void);
struct thread *tqueue_front(void);
struct thread *tqueue_next(void);

void tqueue_thread_init(struct thread *thread, struct thread *parent);
int tqueue_get_priority(const struct thread *thread);
void tqueue_add(struct thread *thread);
void tqueue_remove(struct thread *thread);
int32_t tqueue_get_size(void);

/* Priority donation system */
void donation_thread_init(struct thread *thread);
void donation_lock_init(struct lock *lock);
void donation_thread_destroy(struct thread *thread);

void donation_thread_block(struct thread *thread, struct lock *lock);
void donation_thread_unblock(struct thread *thread);

void donation_thread_acquire(struct thread *thread, struct lock *lock);
void donation_thread_release(struct lock *lock);

void donation_set_base_priority(struct thread *thread, int base_priority);
int donation_get_base_priority(const struct thread *thread);

/* Advanced scheduler */
void mlfqs_set_nice(struct thread *thread, int nice);
int mlfqs_get_nice(const struct thread *thread);

void mlfqs_tick(struct thread *thread);
int mlfqs_get_recent_cpu(const struct thread *thread);

void mlfqs_decay(void);
int mlfqs_get_load_avg(void);

#endif /* threads/priority.h */
